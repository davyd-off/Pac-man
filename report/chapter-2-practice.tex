\chapter{\label{ch:ch02}ГЛАВА 2. ЭТАПЫ РАЗРАБОТКИ ИГРЫ. ПРОВЕРКА РАБОТОСПОСОБНОСТИ ПРОГРАММЫ.}

\section{\label{sec:ch02/sec01}Этапы разработки игры.}

\subsection{\label{subsec:ch02/sec01/sub01}Установка собственной частоты кадров.}
\textbf{FPS} --- частота кадров в секунду, демонстрируемая игрой.

Собственная частота кадров --- это первая проблема, с которой пришлось столкнуться при написании кода игры. Например, в библиотеке pygame есть функция \textbf{Clock()},
благодаря которой можно задать собственный FPS. В библиотеке PySDL2 такой функции нет.Для решения данной проблемы была попытка в использовании модуля Pygame\_sdl2.

\textbf{Pygame\_sdl2} --- это повторная реализация API Pygame с использованием SDL2 и связанных библиотек, выпущенная под лицензией Zlib~\cite{pgsdl2EN}.
После установки Pygame\_sdl2, попытка увеличить FPS не увенчалась успехом: модуль просто не работал. Интерпретатор попросту не смог его импортировать в код игры.

И только на этапе тестирования была выявлена причина медленной работы программы. 
Подробнее об этом (см. \texttt{Взаимодействие компьютерной графики с аппаратным или программным обеспечением}~\ref{subsec:ch02/sec01/sub02}).

\subsection{\label{subsec:ch02/sec01/sub02}Взаимодействие компьютерной графики с аппаратным или программным обеспечением.}
Как было сказано выше, проблема установки собственной частоты кадров решилась только на этапе тестирования. На этапе тестирования было замечено, что в режиме <<холостого хода>>
приложение очень стремительно потребляла оперативную память, и в итоге в терминал выводилась ошибка о выходе за пределы памяти (Out of memory). Было нетрудно догадаться,
что FPS было низким из-за большого потребления памяти.

Вообще существовала первая версия данной библиотеки для C/C++ и называлась просто: SDL. Эта версия библиотеки использовала использовала процессор для создания графических объектов.
Для создания графики на этой библиотеке использовался метод \textbf{SDL\_Surface}, который создавал поверхность, на которой можно было <<рисовать>>. А так как обработка всех графических объектов выполнялась процессором, это озночало то, что приложение может сильно тормозить, в зависимости от габаритов объектов (их количества, цветовой палитры и т.д.).

Вторая же версия, которая в частности использовалась для создания игры Pac-man, называется просто: SDL2. В ней, для облегчения работы процессора, используется метод \textbf{SDL\_Renderer},
который предназначен уже для ускорения с помощью видеокарты и прочих компонентов ПК. Помимо этого, в эту версию библиотеки была добавлена возможность для работы с OpenGL, Vulkan, DirectX.
Данный метод позволяет создавать спрайты (графический объект в компьютерной графике). Так вот проблема частоты кадров была именно в этом.

Изначально для создания текстур использовался метод \textbf{TEXTURE}, который загружал картинки и текст и переносл их в контекст рендера, не преобразовывая их в спрайты. Из-за этого было большое
потребление памяти, а следовательно, и маленькая частота кадров. В конечном итоге метод \textbf{TEXTURE} был замёнен на метод \textbf{SpriteFactory}, который загружает картинки и текст в контекст рендера, преобразовывая их в спрайты. В результате получилось, что программа перестала потреблять оперативную память, а следовательно повысилась частота кадров, и игра стала работать намного плавнее.

Также при тестирования игры на компьютерах с различными комплектующими было замечено, что, чем мощнее комплектующие, тем быстрее работает игра. Возможно это зависит от типа оперативной памяти, процессора, видеокарты или от всего вместе.

\subsection{\label{subsec:ch02/sec01/sub03}Создание меню игры.}
Игровое меню --- первое, с чего начиналось создание игры. Для игрового меню был создан класс \textit{ImageButton}, который содержит методы: \textit{\_\_init\_\_}, в котором объявляются переменные для цвета, текстур, самих кнопок и их расположения на экране; \textit{play\_sound}, предназначенный для воспроизведения звука при нажатии на кнопку; \textit{show\_menu}, который отрисовывает кнопки главного меню; \textit{show\_help}, который отрисовывает экран раздела <<Помощь>>; \textit{show\_select}, который отрисовывает экран выбора количества призраков и карты; \textit{render\_clean}, который очищает контекст рендера при нажатии на какую-либо из кнопок (см. \texttt{ПРИЛОЖЕНИЕ} на стр.~\pageref{code:menu} строки 5-71).

\subsection{\label{subsec:ch02/sec01/sub04}Создание карты.}
Изначально карта представляет собой двумернуый массив, заполненный числами от 0 до 9 (см. \texttt{ПРИЛОЖЕНИЕ} на стр.~\pageref{code:b1},~\pageref{code:b2},~\pageref{code:b3}).

В файле \textit{level.py} импортируются файлы с этими массивами (см. \texttt{ПРИЛОЖЕНИЕ} на стр.~\pageref{code:level} строки 3-5).

Функция \textit{selected\_level} предназначена для возврата в главную функцию программы полной копии карты (массива), которую выбирает игрок. В дальнейшем это понадобится не только для первоначальной отрисовки карты, но и для перерисовки карты в случае победы/поражения (см. \texttt{ПРИЛОЖЕНИЕ} на стр.~\pageref{code:level} строки 9-19).

Функция \textit{draw\_board} предназначена, собственно, для отрисовки карты в контекст рендера (см. \texttt{ПРИЛОЖЕНИЕ} на стр.~\pageref{code:level} строки 21-56). Данная функция пробегает по столбцам и строкам массива. В зависимости от числа она добавляет в контекст рендера по координатам соответствующий элемент, отрисовка которого происходит по правилу ниже (см. рисунок~\ref{fig1}).
\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{images/карта.png}
	\caption{Правило отрисовки карты.}
	\label{fig1}
\end{figure}

\subsection{\label{subsec:ch02/sec01/sub05}Создание пакмана и функций для работы с ним.}
Изначально для пакмана создавался класс, но после неудачных попыток по возвращению некоторых переменных в главную функцию программы (пакман не двигался или двигался только вправо/влево), было решено использовать обычные функции.

Функция \textit{draw\_player} предназначена для добавления текстур пакмана в контекст рендера в зависимости от его направления и координат. Также в функцию передаётся переменная-счётчик, благодаря которой пакман как бы открывает и закрывает рот с каждой итерацией главного игрового цикла (см. \texttt{ПРИЛОЖЕНИЕ} на стр.~\pageref{code:player} строки 13-29).

Функция \textit{check\_position} предназначена для проверки на столкновение пакмана со стенкой лабиринта в зависимости от его направления и координат центра персонажа (см. \texttt{ПРИЛОЖЕНИЕ} на стр.~\pageref{code:player} строки 31-79). В главную функцию игры она возвращает значения: разрешено ли дальнейшее движение в указанном направлении или нет?

Функция \textit{move} предназначена для движения пакмана в зависимости от его направления и разрешения движения в данном направлении. Скорость пакмана равна двум, движение осуществляется просто: к координате пакмана по оси X с каждой итерацией игрового цикла прибавляется значение скорости (т.е. когда пакман движется горизонтально), а когда пакман движется вертикально, то от координаты по оси Y отнимается значение скорости (см. \texttt{ПРИЛОЖЕНИЕ} на стр.~\pageref{code:player} строки 81-93).

Функция \textit{check\_target} предназначена для поедания точек и призраков пакманом. Если координата центра пакмана совпадает с 1 в массиве карты, то 1 заменяется на 0, и точка уже не отрисовывается (см. \texttt{Создание карты} на стр.~\pageref{subsec:ch02/sec01/sub04}), при этом значение счётчика увеличивается на 10 в соответствии с правилами игры (см. \texttt{Правила игры} на стр.~\pageref{subsec:ch01/sec04/subsec02}), а также воспроизводится звук поедания точки. Если координата центра пакмана совпадает с 2 в массиве карты, то 2 заменяется на 0, и энерджайзер уже не отрисовывается (см. \texttt{Создание карты} на стр.~\pageref{subsec:ch02/sec01/sub04}), при этом значение счётчика увеличивается на 50, призраки становятся уязвимы, начинается отсчёт времени действия энерджайзера в соответствии с правилами игры (см. \texttt{Правила игры} на стр.~\pageref{subsec:ch01/sec04/subsec02}), а также воспроизводится звук поедания точки. В главную функцию check\_target возвращает значение счётчика, статус энерджайзера, начало отсчёта времени действия энерджайзера, статус съеденного призрака (см. \texttt{ПРИЛОЖЕНИЕ} на стр.~\pageref{code:player} строки 95-113).

Функция \textit{draw\_counter} предназначена для отрисовки на экране количества очков, статуса энерджайзера, жизней пакмана и надписи в случае проигрыша или поражения (см. \texttt{ПРИЛОЖЕНИЕ} на стр.~\pageref{code:player} строки 115-132).

Блок функций \textit{get\_targets\_4 - get\_targets\_7} предназначен для взаимодействия координат пакмана с координатами призраков в зависимости от количества выбранных призраков игроком. Если энерджайзер активен и призраки не съедены, то они начинают беспорядочное движение, по сути как бы убегают от пакмана. Если энерджайзер активен и призраки съедены, то их глаза возвращаются в место их перерождения. Если энерджайзер активен и призраки переродились, то они выходят из своей <<коробки>> и продолжают преследование пакмана. Если же энерджайзер не активен и призраки не съдены, то они преследуют пакмана. В противном случае, если они были съедены после окончания действия энерджайзера, то их глаза возвращаются в место их перерождения (см. \texttt{ПРИЛОЖЕНИЕ} на стр.~\pageref{code:player} строки 134-559).

\subsection{\label{subsec:ch02/sec01/sub06}Создание призраков.}
В связи с тем, что по ТЗ требуется возможность выбора количества призраков, то исходя из таких задач был создан класс \textit{Ghost}. 

Метод \textit{\_\_init\_\_} предназначен для объявления переменных, которые представляют собой характеристики каждого из призраков: координаты, координаты центра, координаты для преследования пакмана (см. \texttt{Создание пакмана и функций для работы с ним} о блоке функций \textit{get\_targets\_4 - get\_targets\_7} на стр.~\pageref{subsec:ch02/sec01/sub05}), текстуры, идентификационный номер, хитбокс, статус: призрак жив, в <<коробке>>, энерджайзер активен (см. \texttt{ПРИЛОЖЕНИЕ} на стр.~\pageref{code:ghost} строки 7-28).

Метод \textit{draw\_ghost} предназначен для добавления текстур призраков контекст рендера в зависимости от его идентификационного номера и статуса (жив, съеден или энерджайзер активен). Также, после добавления текстур, данный метод создаёт хитбокс призрака и возвращает его в метод \textit{\_\_init\_\_} (см. \texttt{ПРИЛОЖЕНИЕ} на стр.~\pageref{code:ghost} строки 30-42).

Метод \textit{check\_collisions} предназначен для проверки столкновения призраков со стенкой, а также для движения в указанном направлении. Данный метод работает аналогично функции \textit{check\_position} для пакмана (см. \texttt{Создание пакмана и функций для работы с ним} о функции \textit{check\_position} на стр.~\pageref{subsec:ch02/sec01/sub05}). Единственное отличие в том, что на призраков ещё накладываются условия о состоянии их статуса: жив (выход из коробки и в дальнейшем он в неё не заходит), съеден (глаза возвращаются обратно в <<коробку>>) и в <<коробке>> ли он (перерождение). В конце своей работы метод возвращает информацию о разрешении движения в указанном направлении, а также статус: в <<коробке>> ли призрак, в метод \textit{\_\_init\_\_} (см. \texttt{ПРИЛОЖЕНИЕ} на стр.~\pageref{code:ghost} строки 44-121).

Блок методов \textit{move\_blinky - move\_clyde} предназначен для движения призраков. Движение определяется в зависимости от координат призраков, разрешения движения в данном направлении, а также от координат, которые получаются из блока функций \textit{get\_targets\_4 - get\_targets\_7} (см. \texttt{Создание пакмана и функций для работы с ним} о блоке функций \textit{get\_targets\_4 - get\_targets\_7} на стр.~\pageref{subsec:ch02/sec01/sub05}). Также призраки обладают разной скоростью в зависимости от статуса: жив --- скорость равна 2, испуган (энерджайзер активен) --- скорость равна 1, съеден (движение глаз) --- скорость равна 4. Ко всему прочему, призраки имеют разную модель передвижения. Так как по ТЗ не важно, как двигаются призраки, но всё равно была предпринята попытка сделать движение призраков исходя из правил их поведения (см. \texttt{Поведение призраков} на стр.~\pageref{subsec:ch01/sec04/subsec03}):
\begin{itemize}
	\item Движение Блинки (красного, метод \textit{move\_blinky}) выполняется следующим образом: он поворачивается при каждом столкновении со стенкой, в противном случае
	продолжает движение прямо (см. \texttt{ПРИЛОЖЕНИЕ} на стр.~\pageref{code:ghost} строки 123-235).
	\item Движение Инки (голубого, метод \textit{move\_inky}) выполняется следующим образом: он поворачивает в любой момент вверх и вниз, чтобы преследовать пакмана, но влево и вправо только при столкновении со стенкой (см. \texttt{ПРИЛОЖЕНИЕ} на стр.~\pageref{code:ghost} строки 237-365).
	\item Движение Пинки (розового, метод \textit{move\_pinky}) выполняется следующим образом: он поворачивает в любой момент влево и вправо, чтобы преследовать пакмана, но вверх и вниз только при столкновении со стенкой (см. \texttt{ПРИЛОЖЕНИЕ} на стр.~\pageref{code:ghost} строки 367-498).
	\item Движение Клайда (оранжевого, метод \textit{move\_clyde}) выполняется следующим образом: он разваорачивается тогда, когда это выгодно для преследования пакмана (см. \texttt{ПРИЛОЖЕНИЕ} на стр.~\pageref{code:ghost} строки 500-644).
\end{itemize}

В конце каждый из этих методов возвращает в главный цикл игры координаты призраков и значения их направлений (0 -- вправо, 1 -- влево, 2 -- вверх, 3 -- вниз).

\subsection{\label{subsec:ch02/sec01/sub07}Главная функция игры.}
В главной функции игры инициализируется графическая библиотека \textit{init(), quit()}. Всё, что требуется для игры, прописывается между этими командами.

До главного игрового цикла происходит создание окна игры, рендера для отрисовки текстур, инициализация аудиоканала, объявление фабричного класса для создания спрайтов (текстур), переменных для работы с функциями пакмана, призраков, меню и игры, а также загрузка текстур и создание экземпляра класса кнопок (см. \texttt{ПРИЛОЖЕНИЕ} на стр.~\pageref{code:main} строки 11-135).

Мною было принято решение передавать переменные в функции пакмана и т.п. из главного цикла, потому что, во-первых, их значения изменяются с каждой итерацией игрового цикла, во-вторых, текстуры нужно загружать однажды, чтобы избежать торможения игры, как и было сказано выше (см. \texttt{Взаимодействие компьютерной графики с аппаратным или программным обеспечением} на стр.~\pageref{subsec:ch02/sec01/sub02}).

Игровой цикл условно можно разделить на несколько блоков: работа с меню игры, работа с самой игрой, обработка событий (нажатие кнопок). 

В блоке работы с меню игры обрабатываются все действия игрока: нажатие на кнопки, смена экранов, выбор количества призраков и карты, возврат на предыдущий экран. Если вдруг пользователь выбрал не то количество призраков или не ту карту, то ему следует нажать кнопку <<Назад>> и повторить операцию выбора (см. \texttt{ПРИЛОЖЕНИЕ} на стр.~\pageref{code:main} строки 138-152, 1584-1631). 

В блоке работы с игрой выполняется следующее: в зависимости от выбора игроком количества призраков и карты, создаётся соответствующее игровое поле. В начале отрабатывают счётчики, благодаря которым пакман и призраки не двигаются. Как только они начинают свои движения, то их первоначальные характеристики начинают изменяться с каждой итерацией и передаются в функции, описанные выше. 

Например, разберу случай выбора 4-ёх призраков и 1-ой карты. Как только в главном меню сделан выбор, то в функцию \textit{selected\_level} передаётся булева переменная в соответствии с выбранным уровнем, а она загружает и возвращает соответствующий. Далее происходит отработка счётчиков, описанных выше. Затем отрисовывается лабиринт со всеми точками. Потом создаётся хитбокс пакмана, который также зависит от его изменяющихся координат. Так как было выбрано 4 призрака, создается 4 экземпляра класса \textit{Ghost}, в которые передаются все переменные для работы с призраками, которые в свою очередь тоже меняются с каждой итерацией и ситуацией на игровом поле; выполняется вызов функций \textit{draw\_counter, get\_targets\_4, check\_position}, которые были описаны выше. Затем вызываются методы для движения пакмана и призраков. Управление пакманом осуществляется за счёт стрелок на клавиатуре (при нажатии на стрелку изменяется соответствующая переменная для направления движения, а уже в зависимости от направления проверяется проверка: разрешено ли туда двигаться или нет). При этом пакман проходит через тоннель и появляется с другой стороны лабиринта. Далее выполняется проверка на столкновение хитбоксов пакмана и призраков в зависимости от разных ситуаций:
\begin{itemize}
	\item Энерджайзер не активен -- при столкновении пакмана с призраком отнимается жизнь, все переменные принимают своё первоначальное значение, но съеденные точки не отображаются, счётчик не обнуляется.
	\item Энерджайзер активен -- пока другие призраки испуганы, при столкновении пакмана с перерождённым призраком отнимается жизнь, все переменные принимают своё первоначальное значение, но съеденные точки не отображаются, счётчик не обнуляется. При этом столкновение пакмана и глаз ни к чему не приводит.
	\item Энерджайзер активен -- если нет перерождённых или съеденных призраков (их глаз), пакман сталкивается с испуганным призраком, он превращатся в глаза, возвращается в <<коробку>> и перераждается.
\end{itemize}
В зависимости от типа столкновений изменяются скорости призраков, описание которых приведено выше (см. \texttt{Создание призраков} на стр.~\pageref{subsec:ch02/sec01/sub06}). Если жизней не осталось, то объекты останавливаются, выводится сообщении о проигрыше, и после нажатия на кнопку <<SPACE>> происходит перезапуск игры. Аналогично и для выигрыша, только проверяется условие на наличие точек в игровом поле.
 
Далее все проверки повторяются с каждой итерацией игрового цикла, начиная с первого пункта. Аналогично происходит для разного количества призраков и другой карты (см. \texttt{ПРИЛОЖЕНИЕ} на стр.~\pageref{code:main} строки 154-1574, 1638-1707).

Помимо всего в начале игры, при поедании пакманом точек и призраков, их перерождении воспроизводится звук.

С каждой итерацией игрового цикла рендер показывается и очищается, окно обновляется. Таким образом и происходит смена кадров.

\subsection{\label{subsec:ch02/sec01/sub08}Блок-схема.}
Поскольку выше я описал принцип работы программы, то решил сделать блок-схему более абстрагированной ввиду громоздкости кода программы. Блок-схема, описывающая алгоритмы и процессы в программе, приведена на рисунках~\ref{fig7}~\ref{fig8}.
\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\linewidth]{images/flow1.png}
	\caption{Блок-схема алгоритма программы.}
	\label{fig7}
\end{figure}
\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{images/flow2.png}
	\caption{Блок-схема алгоритма программы.}
	\label{fig8}
\end{figure}

\section{\label{sec:ch02/sec02}Проверка работоспособности программы.}
При запуске игры нас встречает главное меню (см. \texttt{ПРИЛОЖЕНИЕ} на стр.~\pageref{fig2}).

При нажатии на кнопку <<Помощь>> меняется экран. На нём отображена инфорамация в соответствии с ТЗ (см. \texttt{ПРИЛОЖЕНИЕ} на стр.~\pageref{fig3}).

При нажатии на кнопку <<Начать игру>> меняется экран. На нём отображены кнопки выбора количества призраков и карты в соответствии с ТЗ (см. \texttt{ПРИЛОЖЕНИЕ} на стр.~\pageref{fig4}).

Для примера описанного выше (см. \texttt{Главная функция игры} на стр.~\pageref{subsec:ch02/sec01/sub07}) игровое поле выглядит следующим образом (см. \texttt{ПРИЛОЖЕНИЕ} на стр.~\pageref{fig5}).

Пример ситуации, когда пакман потерял одну жизнь, некоторые призраки испуганы, съедены (глаза) и перерождены приведены ниже (см. \texttt{ПРИЛОЖЕНИЕ} на стр.~\pageref{fig6}).